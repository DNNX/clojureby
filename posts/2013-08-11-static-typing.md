#title: Нужна ли статическая типизация в Clojure?
#tags: clojure_tips news
#date: 2013-08-11
#author: Дмитрий Бушенко (d.bushenko@gmail.com)

Хотелось бы порассуждать о наболевшем: о статической типизации в Clojure. Не секрет, что это мой любимый язык программирования, и нравится он мне за свою простоту, функциональный стиль, потрясающую гибкость, поддержку платформы JVM и JavaScript и высокую скорость разработки. Мне нравится, что в нем нет статической типизации, т.к. она тормозит процесс разработки, когда в режиме прототипирования "набрасываешь" черновик функционала и постепенно переделываешь его в нормальный рабочий исходник.

И мне очень не хватает статической типизации, когда приходит время переделывать и рефакторить исходник.

Конечно, до какой-то степени статическую типизацию вполне может заменить юнит-тестирование. Но, согласитесь, писать тесты для каждой функции только для проверки того, что другие функции вызываются в ней с правильным числом параметров -- это уже слишком.

Если в "обычной" JVM-ной Clojure эта проблема стоит еще не так остро (все-таки нормальный stacktrace мы получим в случае ошибки), то с cljs -- беда. В случае ошибки приложение просто перестает работать без каких-либо внятных объяснений.

Над этой проблемой, конечно, работают. Например, вот [здесь](https://github.com/clojure/core.typed) -- интересный проект, позволяющий переделать Clojure в Haskell. Статическая типизация и вывод типов -- вот, что добавляет этот проект в Clojure. Все бы хорошо, но первые же эксперименты с core.typed показали, что им совершенно невозможно пользоваться, слишком сырой.

А что, собственно, лично мне нужно от статической типизации в Clojure?

* Проверка количества параметров, которые переданы в функцию
* Если для параметров указаны типы -- то проверить и их

Причем вывод типов мне не очень-то нужен, я могу указать тип функции примерно так же, как я делаю это в Java.

Поскольку на нашем Clojure-ном проекте скоро грядет вторая итерация и, видимо, переделка части кода, я решил попробовать сделать такой инструмент для себя. Он еще не закончен и находится на стадии проверки идеи, посмотреть можно [здесь](https://github.com/dbushenko/static-types).

Сейчас с помощью этого проекта я могу проверять в исходниках на clj и cljs правильное ли количество параметров передают в мои функции.

Например, у меня есть файл myns.clj с объявлением двух функций:

```clojure
(ns myns)

(defn func1 [a b]
  (+ a b))

(defn func2 [c]
  (+ c (func1 1 2)))
```

В файле testns.clj я вызываю функции из myns:

```clojure
(ns testns
  (:require [myns :as m]))

(defn my-func1 []
  (m/func1 1 2))

(defn my-func2 []
  (m/func2))

(defn my-func3 []
  (m/func1))

(defn my-func4 [a b]
  (m/func2 1 2 3))
```

Как видите, без ошибок объявлена только my-func1. Проверить это можно вот так:

```shell
user> (static-types.core/check-ns1-funcs-in-ns2 "myns.clj" "testns.clj")
Error in my-func2 calling m/func2
You should provide 1 parameters!

Error in my-func3 calling m/func1
You should provide 2 parameters!

Error in my-func4 calling m/func2
You should provide 1 parameters!
```

Здесь мы получаем нормальное сообщение об ошибках с указанием функций, в которых эти ошибки сделаны.

Думаю, стоит доделать еще и проверку типов параметров, а также leiningen-плагин, который будет запускать проверку из консоли.